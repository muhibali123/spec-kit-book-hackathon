---
title: "Physics Simulation and Prediction"
description: "Learn how humanoid robots simulate physical interactions and predict the consequences of their actions in the real world."
tags: ["physics simulation", "prediction", "embodied AI", "world modeling", "motion planning"]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Physics Simulation and Prediction

## Learning Objectives

By the end of this lesson, students will be able to:
- Explain the principles of physics simulation in embodied AI systems
- Implement basic physics simulation for predicting object interactions
- Understand the relationship between physics simulation and world modeling
- Analyze the challenges of real-time physics prediction in robotics
- Evaluate different approaches to physics simulation for humanoid robots

## Key Concepts

- **Physics Simulation**: Computational modeling of physical laws to predict object behavior
- **Forward Dynamics**: Calculating future states based on current state and applied forces
- **Inverse Dynamics**: Determining forces needed to achieve desired motion
- **Collision Detection**: Algorithms for detecting when objects interact
- **Rigid Body Dynamics**: Simulation of non-deformable objects with mass and inertia
- **Soft Body Simulation**: Modeling deformable objects and materials
- **Physics Engines**: Software libraries that handle complex physics calculations
- **Real-time Simulation**: Physics simulation that runs at interactive speeds

## Theory Summary

Physics simulation is a critical component of embodied AI systems, enabling humanoid robots to predict the consequences of their actions before executing them. This predictive capability allows robots to plan actions that are physically feasible and to anticipate the effects of their interactions with the environment.

Forward dynamics simulation calculates the future state of a system given its current state and the forces applied to it. For a humanoid robot, this might involve predicting how a ball will move when it's hit, or how the robot's own body will respond to motor commands. This type of simulation requires solving complex differential equations that describe motion, forces, and constraints.

Inverse dynamics, conversely, calculates the forces required to achieve a desired motion. This is particularly important for humanoid robots when planning movements that must account for physical constraints and interactions with objects in the environment.

Collision detection algorithms identify when objects in the simulation come into contact with each other. This is essential for realistic simulation and for planning actions that avoid unwanted collisions or achieve desired contacts.

Rigid body dynamics assumes that objects do not deform under applied forces, which is a reasonable approximation for many robotic applications. Rigid bodies are characterized by their mass, center of mass, and moment of inertia, allowing for accurate simulation of their motion and interactions.

Soft body simulation extends rigid body dynamics to include deformable objects like cloth, foam, or biological tissues. This is crucial for humanoid robots that must interact with soft or deformable objects in their environment.

Physics engines are specialized software libraries that handle the complex calculations required for physics simulation. Popular engines like Bullet, ODE (Open Dynamics Engine), and NVIDIA PhysX provide optimized implementations of collision detection, rigid body dynamics, and other physics-related algorithms.

Real-time physics simulation requires balancing accuracy with computational efficiency. Humanoid robots often need to make quick decisions based on physics predictions, necessitating simulation that can run at interactive speeds (typically 60+ Hz).

## Hands-on Activity

### Activity: Implementing a Simple Physics Simulation Engine

In this activity, you'll create a basic physics simulation engine that can predict the motion of objects in a 2D environment, including collision detection and response.

<Tabs>
<TabItem value="python" label="Python Implementation">

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
import matplotlib.animation as animation
from typing import List, Tuple

class PhysicsObject:
    def __init__(self, position, velocity, mass, radius=1.0, color='blue'):
        self.position = np.array(position, dtype=float)
        self.velocity = np.array(velocity, dtype=float)
        self.mass = mass
        self.radius = radius
        self.color = color
        self.forces = np.array([0.0, 0.0])
        self.restitution = 0.8  # Coefficient of restitution (bounciness)

    def apply_force(self, force):
        """Apply a force to the object"""
        self.forces += force

    def update(self, dt):
        """Update the object's state based on forces and velocity"""
        # Calculate acceleration (F = ma => a = F/m)
        acceleration = self.forces / self.mass

        # Update velocity (v = v0 + a*dt)
        self.velocity += acceleration * dt

        # Update position (x = x0 + v*dt)
        self.position += self.velocity * dt

        # Reset forces for next time step
        self.forces = np.array([0.0, 0.0])

        # Apply simple damping to simulate air resistance
        self.velocity *= 0.99

class PhysicsWorld:
    def __init__(self, width=10, height=10):
        self.width = width
        self.height = height
        self.objects: List[PhysicsObject] = []
        self.gravity = np.array([0, -9.81])  # Gravity pointing downward
        self.bounds = True

    def add_object(self, obj: PhysicsObject):
        """Add an object to the simulation"""
        self.objects.append(obj)

    def update(self, dt):
        """Update the entire physics world"""
        for obj in self.objects:
            # Apply gravity to each object
            obj.apply_force(self.gravity * obj.mass)

            # Update each object
            obj.update(dt)

            # Handle boundary collisions
            if self.bounds:
                self._handle_boundary_collision(obj)

        # Handle object-to-object collisions
        self._handle_object_collisions()

    def _handle_boundary_collision(self, obj: PhysicsObject):
        """Handle collisions with world boundaries"""
        # Left and right walls
        if obj.position[0] - obj.radius < -self.width/2:
            obj.position[0] = -self.width/2 + obj.radius
            obj.velocity[0] = -obj.velocity[0] * obj.restitution
        elif obj.position[0] + obj.radius > self.width/2:
            obj.position[0] = self.width/2 - obj.radius
            obj.velocity[0] = -obj.velocity[0] * obj.restitution

        # Bottom and top walls
        if obj.position[1] - obj.radius < -self.height/2:
            obj.position[1] = -self.height/2 + obj.radius
            obj.velocity[1] = -obj.velocity[1] * obj.restitution
        elif obj.position[1] + obj.radius > self.height/2:
            obj.position[1] = self.height/2 - obj.radius
            obj.velocity[1] = -obj.velocity[1] * obj.restitution

    def _handle_object_collisions(self):
        """Handle collisions between objects"""
        for i in range(len(self.objects)):
            for j in range(i + 1, len(self.objects)):
                obj1 = self.objects[i]
                obj2 = self.objects[j]

                # Calculate distance between centers
                dist_vec = obj2.position - obj1.position
                dist = np.linalg.norm(dist_vec)

                # Check if objects are colliding
                if dist < obj1.radius + obj2.radius:
                    # Calculate collision normal (from obj1 to obj2)
                    normal = dist_vec / dist if dist > 0 else np.array([1, 0])

                    # Calculate relative velocity
                    rel_velocity = obj2.velocity - obj1.velocity

                    # Calculate velocity along normal
                    vel_along_normal = np.dot(rel_velocity, normal)

                    # Only resolve if objects are moving toward each other
                    if vel_along_normal < 0:
                        # Calculate impulse scalar
                        e = min(obj1.restitution, obj2.restitution)  # Coefficient of restitution
                        j = -(1 + e) * vel_along_normal
                        j /= 1/obj1.mass + 1/obj2.mass

                        # Apply impulse
                        impulse = j * normal
                        obj1.velocity -= impulse / obj1.mass
                        obj2.velocity += impulse / obj2.mass

                        # Position correction to prevent sticking
                        overlap = (obj1.radius + obj2.radius) - dist
                        correction = normal * overlap * 0.5
                        obj1.position -= correction
                        obj2.position += correction

    def predict_motion(self, obj_index: int, time_horizon: float, dt: float = 0.01) -> List[np.ndarray]:
        """Predict the future trajectory of an object"""
        original_obj = self.objects[obj_index]

        # Create a temporary copy of the object
        temp_obj = PhysicsObject(
            position=original_obj.position.copy(),
            velocity=original_obj.velocity.copy(),
            mass=original_obj.mass,
            radius=original_obj.radius,
            color=original_obj.color
        )
        temp_obj.restitution = original_obj.restitution
        temp_obj.forces = original_obj.forces.copy()

        # Create a temporary world with just the object
        temp_world = PhysicsWorld(self.width, self.height)
        temp_world.gravity = self.gravity.copy()
        temp_world.add_object(temp_obj)

        trajectory = [temp_obj.position.copy()]

        steps = int(time_horizon / dt)
        for _ in range(steps):
            temp_world.update(dt)
            trajectory.append(temp_obj.position.copy())

        return trajectory

    def visualize(self, ax, show_predictions=True):
        """Visualize the physics world"""
        ax.clear()
        ax.set_xlim(-self.width/2, self.width/2)
        ax.set_ylim(-self.height/2, self.height/2)
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3)
        ax.set_title('Physics Simulation: Objects and Predictions')

        # Draw boundaries
        boundary = Rectangle((-self.width/2, -self.height/2), self.width, self.height,
                            linewidth=2, edgecolor='black', facecolor='none')
        ax.add_patch(boundary)

        # Draw objects
        for obj in self.objects:
            circle = Circle(obj.position, obj.radius, color=obj.color, alpha=0.7)
            ax.add_patch(circle)

            # Draw velocity vector
            if np.linalg.norm(obj.velocity) > 0.1:  # Only draw if velocity is significant
                ax.arrow(obj.position[0], obj.position[1],
                        obj.velocity[0]*0.1, obj.velocity[1]*0.1,
                        head_width=0.1, head_length=0.1, fc='red', ec='red')

        # Draw predictions for the first object if available
        if show_predictions and len(self.objects) > 0:
            prediction = self.predict_motion(0, 2.0, 0.1)  # Predict 2 seconds ahead
            if len(prediction) > 1:
                pred_x = [p[0] for p in prediction]
                pred_y = [p[1] for p in prediction]
                ax.plot(pred_x, pred_y, 'r--', alpha=0.5, label='Prediction')
                ax.legend()

def simulate_physics():
    """Run a physics simulation with multiple objects"""
    world = PhysicsWorld(12, 12)

    # Add objects to the simulation
    obj1 = PhysicsObject([0, 0], [2, 3], 1.0, 0.5, 'blue')
    world.add_object(obj1)

    obj2 = PhysicsObject([-3, 2], [1, 0], 1.5, 0.7, 'red')
    world.add_object(obj2)

    obj3 = PhysicsObject([2, -2], [0, 1], 0.8, 0.4, 'green')
    world.add_object(obj3)

    # Create animation
    fig, ax = plt.subplots(figsize=(12, 8))

    def animate(frame):
        # Update physics world
        world.update(0.05)  # 50ms time step
        world.visualize(ax)
        ax.set_title(f'Physics Simulation - Frame {frame}')

    anim = animation.FuncAnimation(fig, animate, frames=500, interval=50, repeat=True)
    plt.tight_layout()
    plt.show()

    return world, anim

# Example usage
def run_physics_example():
    """Run an example physics simulation"""
    world = PhysicsWorld(10, 10)

    # Add a bouncing ball
    ball = PhysicsObject([0, 4], [3, 0], 1.0, 0.5, 'blue')
    world.add_object(ball)

    # Add another object
    block = PhysicsObject([-2, 0], [0, 0], 2.0, 0.6, 'red')
    block.restitution = 0.5  # Less bouncy
    world.add_object(block)

    # Run simulation for a few steps and print positions
    print("Physics Simulation Results:")
    print("Time\tBall X\tBall Y\tBlock X\tBlock Y")
    print("-" * 40)

    for i in range(20):
        time = i * 0.1
        world.update(0.1)

        ball_pos = world.objects[0].position
        block_pos = world.objects[1].position

        print(f"{time:.1f}\t{ball_pos[0]:.2f}\t{ball_pos[1]:.2f}\t{block_pos[0]:.2f}\t{block_pos[1]:.2f}")

        # Predict where the ball will be in 1 second
        if i == 10:  # At time 1.0s, predict 1 second ahead
            prediction = world.predict_motion(0, 1.0, 0.1)
            if prediction:
                future_pos = prediction[-1]
                print(f"\nPrediction at t=1.0s: Ball will be at ({future_pos[0]:.2f}, {future_pos[1]:.2f}) in 1 second")

    return world

# Run the example
world = run_physics_example()
print("\nPhysics simulation completed!")
print("The simulation demonstrates how humanoid robots can predict the consequences of physical interactions.")
```

</TabItem>
</Tabs>

## Tools & Components Required

- Python 3.7 or higher
- NumPy for numerical computations
- Matplotlib for visualization and animation
- Basic understanding of physics concepts (forces, motion, collisions)
- Knowledge of vector mathematics

## Step-by-Step Instructions

1. **Create Physics Object Class**: Implement a class to represent physical objects with position, velocity, mass, and other properties
2. **Implement Force Application**: Add methods to apply forces to objects and calculate resulting motion
3. **Build Physics World**: Create a container class to manage multiple objects and apply global forces like gravity
4. **Add Collision Detection**: Implement algorithms to detect and respond to collisions between objects and boundaries
5. **Implement Prediction**: Create methods to predict future trajectories based on current physics state
6. **Visualize Simulation**: Add visualization capabilities to see the physics in action
7. **Test with Various Scenarios**: Experiment with different object configurations and physical parameters

## Code Snippets

### Physics Object Update Method

```python
def update(self, dt):
    """Update the object's state based on forces and velocity"""
    # Calculate acceleration (F = ma => a = F/m)
    acceleration = self.forces / self.mass

    # Update velocity (v = v0 + a*dt)
    self.velocity += acceleration * dt

    # Update position (x = x0 + v*dt)
    self.position += self.velocity * dt

    # Reset forces for next time step
    self.forces = np.array([0.0, 0.0])

    # Apply simple damping to simulate air resistance
    self.velocity *= 0.99
```

### Collision Detection and Response

```python
def _handle_object_collisions(self):
    """Handle collisions between objects"""
    for i in range(len(self.objects)):
        for j in range(i + 1, len(self.objects)):
            obj1 = self.objects[i]
            obj2 = self.objects[j]

            # Calculate distance between centers
            dist_vec = obj2.position - obj1.position
            dist = np.linalg.norm(dist_vec)

            # Check if objects are colliding
            if dist < obj1.radius + obj2.radius:
                # Calculate collision normal (from obj1 to obj2)
                normal = dist_vec / dist if dist > 0 else np.array([1, 0])

                # Calculate relative velocity
                rel_velocity = obj2.velocity - obj1.velocity

                # Calculate velocity along normal
                vel_along_normal = np.dot(rel_velocity, normal)

                # Only resolve if objects are moving toward each other
                if vel_along_normal < 0:
                    # Calculate impulse scalar
                    e = min(obj1.restitution, obj2.restitution)  # Coefficient of restitution
                    j = -(1 + e) * vel_along_normal
                    j /= 1/obj1.mass + 1/obj2.mass

                    # Apply impulse
                    impulse = j * normal
                    obj1.velocity -= impulse / obj1.mass
                    obj2.velocity += impulse / obj2.mass
```

## Review Questions

1. What is the difference between forward dynamics and inverse dynamics in physics simulation?
2. How does collision detection contribute to realistic physics simulation?
3. What are the challenges of implementing real-time physics simulation for humanoid robots?
4. How can physics simulation help humanoid robots predict the consequences of their actions?
5. What is the role of restitution in collision response?

## Mini Assessment

<Tabs>
<TabItem value="question1" label="Question 1">

**Which approach is most computationally efficient for real-time physics simulation on humanoid robots?**

A) High-fidelity soft body simulation
B) Simplified rigid body dynamics with approximations
C) Full finite element analysis
D) Detailed molecular dynamics

<details>
<summary>Answer</summary>
B) Simplified rigid body dynamics with approximations - This approach provides a good balance between accuracy and computational efficiency for real-time applications.
</details>

</TabItem>

<TabItem value="question2" label="Question 2">

**What does the coefficient of restitution represent in collision physics?**

A) Friction between surfaces
B) Bounciness of the collision
C) Mass of the objects
D) Velocity of impact

<details>
<summary>Answer</summary>
B) Bounciness of the collision - The coefficient of restitution determines how much kinetic energy is preserved during a collision, affecting how "bouncy" the collision appears.
</details>

</TabItem>
</Tabs>

## Practical Task

Extend the physics simulation to include a simple articulated body system (like a robotic arm). Add joints between objects and implement constraints that simulate the movement of a multi-joint system. Test how your humanoid robot could use this simulation to predict the motion of its own limbs and the consequences of motor commands.

## Expected Outcomes

After completing this lesson, you should be able to:
- Implement basic physics simulation for humanoid robot applications
- Understand the trade-offs between simulation accuracy and computational efficiency
- Create prediction systems that help robots anticipate physical interactions
- Apply physics principles to motion planning and control
- Design simulation systems that run in real-time for robotic applications