---
title: "Trajectory Generation and Motion Control"
description: "Creating smooth trajectories and controlling motion execution in humanoid robots"
tags: [trajectory-generation, motion-control, splines, interpolation, humanoid-kinematics]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Trajectory Generation and Motion Control

## Learning Objectives

After completing this lesson, you will be able to:
- Generate smooth trajectories for humanoid robot joints and end-effectors
- Implement various interpolation methods for motion control
- Design motion controllers that track desired trajectories
- Analyze the effects of trajectory planning on robot performance

## Key Concepts

- **Spline Interpolation**: Creating smooth curves through specified waypoints
- **Joint Space Trajectories**: Planning motion in robot's joint coordinate system
- **Cartesian Space Trajectories**: Planning motion in task space coordinates
- **Velocity and Acceleration Profiles**: Controlling motion dynamics
- **Feedforward Control**: Anticipating motion requirements for better tracking

## Theory Summary

Trajectory generation is essential for creating smooth, controlled motion in humanoid robots. The process involves planning the desired path of robot joints or end-effectors over time, considering kinematic and dynamic constraints. Smooth trajectories are critical for stable locomotion, graceful manipulation, and safe human-robot interaction.

Different types of trajectories serve various purposes: minimum-jerk trajectories for smooth biological-like motion, trapezoidal velocity profiles for efficient point-to-point motion, and spline-based trajectories for complex paths. The choice of trajectory type depends on the application requirements and robot constraints.

Motion control systems track these trajectories using feedback and feedforward control. Feedback control corrects for errors between desired and actual motion, while feedforward control anticipates the control inputs needed for the desired motion, improving tracking performance.

## Hands-On Activity

<Tabs>
<TabItem value="trajectory-generation" label="Trajectory Generation">
Implement different trajectory generation methods for robot motion.
</TabItem>
<TabItem value="motion-control" label="Motion Control">
Create a motion controller that tracks generated trajectories.
</TabItem>
<TabItem value="performance-analysis" label="Performance Analysis">
Analyze the tracking performance of different trajectory types.
</TabItem>
</Tabs>

## Tools & Components Required

- Python with NumPy and SciPy
- Control systems library
- Basic understanding of kinematics
- Visualization tools for trajectory analysis

## Step-by-Step Instructions

1. Implement basic interpolation methods (linear, cubic, quintic)
2. Create trajectory generation functions for joint and Cartesian space
3. Design motion control system to track trajectories
4. Test with different trajectory types and parameters
5. Analyze tracking performance and smoothness
6. Optimize for specific applications

## Code Snippets

```python
import numpy as np
from typing import List, Tuple, Callable
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

class TrajectoryGenerator:
    def __init__(self):
        pass

    def linear_interpolation(self, start: float, end: float, t: float) -> float:
        """Linear interpolation between start and end values"""
        return start + t * (end - start)

    def cubic_interpolation(self, start: float, end: float, t: float) -> float:
        """Cubic interpolation with zero velocity at start and end"""
        # Cubic polynomial: s(t) = a0 + a1*t + a2*t^2 + a3*t^3
        # With boundary conditions: s(0)=start, s(1)=end, s'(0)=0, s'(1)=0
        t_smooth = 3 * t**2 - 2 * t**3
        return start + t_smooth * (end - start)

    def quintic_interpolation(self, start: float, end: float,
                            start_vel: float = 0.0, end_vel: float = 0.0,
                            start_acc: float = 0.0, end_acc: float = 0.0,
                            t: float = 0.0) -> Tuple[float, float, float]:
        """Quintic interpolation with specified velocity and acceleration"""
        # Quintic polynomial ensuring smooth velocity and acceleration profiles
        t2, t3, t4, t5 = t**2, t**3, t**4, t**5
        a0 = start
        a1 = start_vel
        a2 = start_acc / 2
        a3 = -10 * start + 10 * end - 6 * start_vel - 4 * end_vel - 1.5 * start_acc + 0.5 * end_acc
        a4 = 15 * start - 15 * end + 8 * start_vel + 7 * end_vel + 1.5 * start_acc - end_acc
        a5 = -6 * start + 6 * end - 3 * start_vel - 3 * end_vel - 0.5 * start_acc + 0.5 * end_acc

        pos = a0 + a1*t + a2*t2 + a3*t3 + a4*t4 + a5*t5
        vel = a1 + 2*a2*t + 3*a3*t2 + 4*a4*t3 + 5*a5*t4
        acc = 2*a2 + 6*a3*t + 12*a4*t2 + 20*a5*t3

        return pos, vel, acc

    def minimum_jerk_trajectory(self, start: float, end: float, duration: float,
                               current_time: float) -> Tuple[float, float, float]:
        """Generate minimum jerk trajectory (biologically inspired)"""
        if duration <= 0:
            return end, 0, 0

        t = min(max(current_time / duration, 0), 1)  # Normalize and clamp time

        # Minimum jerk trajectory: s(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5
        # With boundary conditions: position, velocity, and acceleration are zero at start/end
        a0 = start
        a1 = 0
        a2 = 0
        a3 = 10 * (end - start) / duration**3
        a4 = -15 * (end - start) / duration**4
        a5 = 6 * (end - start) / duration**5

        t_norm = t * duration
        t2, t3, t4, t5 = t_norm**2, t_norm**3, t_norm**4, t_norm**5

        pos = a0 + a1*t_norm + a2*t2 + a3*t3 + a4*t4 + a5*t5
        vel = a1 + 2*a2*t_norm + 3*a3*t2 + 4*a4*t3 + 5*a5*t4
        acc = 2*a2 + 6*a3*t_norm + 12*a4*t2 + 20*a5*t3

        return pos, vel, acc

    def trapezoidal_velocity_profile(self, start: float, end: float,
                                   max_vel: float, max_acc: float,
                                   current_time: float) -> Tuple[float, float, float]:
        """Generate trapezoidal velocity profile trajectory"""
        distance = abs(end - start)
        direction = 1 if end > start else -1

        # Calculate profile parameters
        accel_time = max_vel / max_acc
        accel_dist = 0.5 * max_acc * accel_time**2

        if 2 * accel_dist > distance:
            # Triangle profile (no constant velocity phase)
            accel_time = np.sqrt(distance / max_acc)
            total_time = 2 * accel_time
            const_time = 0
        else:
            # Trapezoidal profile
            const_dist = distance - 2 * accel_dist
            const_time = const_dist / max_vel
            total_time = 2 * accel_time + const_time

        t = current_time

        if t <= 0:
            return start, 0, 0
        elif t < accel_time:
            # Acceleration phase
            pos = start + direction * 0.5 * max_acc * t**2
            vel = direction * max_acc * t
            acc = direction * max_acc
        elif t < accel_time + const_time:
            # Constant velocity phase
            pos = start + direction * (accel_dist + max_vel * (t - accel_time))
            vel = direction * max_vel
            acc = 0
        elif t < total_time:
            # Deceleration phase
            decel_t = t - (accel_time + const_time)
            pos = start + direction * (accel_dist + const_dist + max_vel * decel_t - 0.5 * max_acc * decel_t**2)
            vel = direction * max_acc * (total_time - t)
            acc = -direction * max_acc
        else:
            # At target
            return end, 0, 0

        return pos, vel, acc

class JointTrajectoryGenerator:
    def __init__(self, num_joints: int):
        self.num_joints = num_joints
        self.trajectory_generator = TrajectoryGenerator()

    def generate_joint_trajectory(self, start_pos: np.ndarray, end_pos: np.ndarray,
                                duration: float, num_points: int = 100) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Generate trajectory for multiple joints"""
        if len(start_pos) != self.num_joints or len(end_pos) != self.num_joints:
            raise ValueError(f"Position vectors must have {self.num_joints} elements")

        time_points = np.linspace(0, duration, num_points)
        positions = np.zeros((num_points, self.num_joints))
        velocities = np.zeros((num_points, self.num_joints))
        accelerations = np.zeros((num_points, self.num_joints))

        for i in range(self.num_joints):
            for j, t in enumerate(time_points):
                pos, vel, acc = self.trajectory_generator.minimum_jerk_trajectory(
                    start_pos[i], end_pos[i], duration, t
                )
                positions[j, i] = pos
                velocities[j, i] = vel
                accelerations[j, i] = acc

        return positions, velocities, accelerations

    def generate_waypoint_trajectory(self, waypoints: List[np.ndarray],
                                   durations: List[float]) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Generate trajectory through multiple waypoints"""
        if len(waypoints) != len(durations) + 1:
            raise ValueError("Number of durations should be one less than number of waypoints")

        all_positions = []
        all_velocities = []
        all_accelerations = []
        all_times = []

        current_time = 0
        for i in range(len(durations)):
            # Generate trajectory segment
            seg_duration = durations[i]
            seg_start = waypoints[i]
            seg_end = waypoints[i+1]

            # For this example, we'll use minimum jerk for each segment
            seg_times = np.linspace(current_time, current_time + seg_duration, int(seg_duration * 100))

            seg_positions = np.zeros((len(seg_times), len(seg_start)))
            seg_velocities = np.zeros((len(seg_times), len(seg_start)))
            seg_accelerations = np.zeros((len(seg_times), len(seg_start)))

            for joint_idx in range(len(seg_start)):
                for t_idx, t in enumerate(seg_times):
                    rel_t = t - current_time
                    pos, vel, acc = self.trajectory_generator.minimum_jerk_trajectory(
                        seg_start[joint_idx], seg_end[joint_idx], seg_duration, rel_t
                    )
                    seg_positions[t_idx, joint_idx] = pos
                    seg_velocities[t_idx, joint_idx] = vel
                    seg_accelerations[t_idx, joint_idx] = acc

            all_positions.append(seg_positions)
            all_velocities.append(seg_velocities)
            all_accelerations.append(seg_accelerations)
            all_times.append(seg_times)

            current_time += seg_duration

        # Concatenate all segments
        full_positions = np.vstack(all_positions)
        full_velocities = np.vstack(all_velocities)
        full_accelerations = np.vstack(all_accelerations)
        full_times = np.concatenate(all_times)

        return full_positions, full_velocities, full_accelerations

class MotionController:
    def __init__(self, num_joints: int, kp: float = 100.0, kv: float = 20.0):
        self.num_joints = num_joints
        self.kp = kp  # Position gain
        self.kv = kv  # Velocity gain
        self.current_positions = np.zeros(num_joints)
        self.current_velocities = np.zeros(num_joints)

    def compute_control(self, desired_pos: np.ndarray, desired_vel: np.ndarray,
                       desired_acc: np.ndarray, feedforward_gain: float = 1.0) -> np.ndarray:
        """Compute control torques using computed torque control"""
        # Feedback: PD control on position and velocity errors
        pos_error = desired_pos - self.current_positions
        vel_error = desired_vel - self.current_velocities

        feedback_torque = self.kp * pos_error + self.kv * vel_error

        # Feedforward: anticipated torques based on desired motion
        feedforward_torque = feedforward_gain * desired_acc

        total_torque = feedback_torque + feedforward_torque

        return total_torque

    def update_state(self, new_positions: np.ndarray, new_velocities: np.ndarray = None):
        """Update current robot state"""
        self.current_positions = new_positions.copy()
        if new_velocities is not None:
            self.current_velocities = new_velocities.copy()
        else:
            # Estimate velocity if not provided
            pass

class CartesianTrajectoryGenerator:
    def __init__(self, robot_kinematics):
        self.kinematics = robot_kinematics

    def cartesian_to_joint_trajectory(self, cartesian_path: List[np.ndarray],
                                    start_joint_config: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Convert Cartesian path to joint space trajectory"""
        # This would use inverse kinematics to convert Cartesian waypoints to joint angles
        # For simplicity, we'll return a placeholder implementation
        num_waypoints = len(cartesian_path)
        num_joints = len(start_joint_config)

        joint_positions = np.zeros((num_waypoints, num_joints))
        joint_velocities = np.zeros((num_waypoints, num_joints))
        joint_accelerations = np.zeros((num_waypoints, num_joints))

        # In a real implementation, this would solve inverse kinematics for each Cartesian point
        # For now, we'll create a simple joint trajectory
        joint_positions[0] = start_joint_config
        for i in range(1, num_waypoints):
            # This is a simplified approach - real implementation would use IK
            joint_positions[i] = start_joint_config + (i/num_waypoints) * (start_joint_config * 0.1)

        # Calculate velocities and accelerations (finite differences)
        for i in range(1, num_waypoints):
            joint_velocities[i] = (joint_positions[i] - joint_positions[i-1]) / 0.01  # Assuming 100Hz control
            if i > 1:
                joint_accelerations[i] = (joint_velocities[i] - joint_velocities[i-1]) / 0.01

        return joint_positions, joint_velocities, joint_accelerations

class SmoothTrajectoryFollower:
    def __init__(self, num_joints: int):
        self.joint_generator = JointTrajectoryGenerator(num_joints)
        self.motion_controller = MotionController(num_joints)
        self.current_time = 0.0

    def follow_trajectory(self, start_pos: np.ndarray, end_pos: np.ndarray,
                         duration: float, dt: float) -> List[Dict]:
        """Follow a trajectory and return control history"""
        history = []

        # Generate the trajectory
        positions, velocities, accelerations = self.joint_generator.generate_joint_trajectory(
            start_pos, end_pos, duration, int(duration/dt) + 1
        )

        # Follow the trajectory
        for i in range(len(positions)):
            # Get desired state
            desired_pos = positions[i]
            desired_vel = velocities[i]
            desired_acc = accelerations[i]

            # Compute control
            control_output = self.motion_controller.compute_control(
                desired_pos, desired_vel, desired_acc
            )

            # Update robot state (simulated)
            self.motion_controller.update_state(desired_pos, desired_vel)

            # Record history
            history.append({
                'time': i * dt,
                'desired_position': desired_pos.copy(),
                'desired_velocity': desired_vel.copy(),
                'desired_acceleration': desired_acc.copy(),
                'control_output': control_output.copy(),
                'error': desired_pos - self.motion_controller.current_positions
            })

        return history

# Example usage
num_joints = 12  # Example for a humanoid arm/leg
joint_generator = JointTrajectoryGenerator(num_joints)

start_pos = np.zeros(num_joints)
end_pos = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])

# Generate trajectory
positions, velocities, accelerations = joint_generator.generate_joint_trajectory(
    start_pos, end_pos, duration=2.0
)

# Create motion controller
motion_controller = MotionController(num_joints)

# Follow trajectory
follower = SmoothTrajectoryFollower(num_joints)
history = follower.follow_trajectory(start_pos, end_pos, duration=2.0, dt=0.01)
```

## Review Questions

1. What are the differences between minimum jerk and trapezoidal velocity trajectories?
2. Why is feedforward control important in motion control systems?
3. How do joint space and Cartesian space trajectories differ?

## Mini Assessment

<Tabs>
<TabItem value="trajectory-comparison" label="Trajectory Comparison">
Compare the smoothness and efficiency of different trajectory types.
</TabItem>
<TabItem value="control-optimization" label="Control Optimization">
Optimize controller gains for best trajectory tracking performance.
</TabItem>
</Tabs>

## Practical Task

Design and implement a complete trajectory generation and motion control system for a humanoid robot that can smoothly execute complex movements while maintaining stability. Test the system with various trajectory types and evaluate tracking performance.

## Expected Outcomes

By the end of this lesson, you should:
- Understand different trajectory generation methods
- Be able to implement motion control systems
- Recognize the importance of smooth motion for humanoid robots
- Appreciate the relationship between trajectory planning and control